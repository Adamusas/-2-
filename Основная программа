import pygame
import os
import sys
import math
from PIL import Image, ImageSequence


def load_image(name, colorkey=None):
    fullname = os.path.join('data', name)
    # если файл не существует, то выходим
    if not os.path.isfile(fullname):
        print(f"Файл с изображением '{fullname}' не найден")
        sys.exit()
    image = pygame.image.load(fullname)
    return image


def split_gif(gif_file):
    # Создаем полный путь к файлу
    gif_path = os.path.join('data', gif_file)  # 'data' - папка, gif_file - имя файла
    img = Image.open(gif_path)  # Открываем GIF-файл
    frames = []  # Инициализируем пустой список для хранения кадров
    for frame in ImageSequence.Iterator(img):  # Проходим по всем кадрам с помощью итератора
        frames.append(frame.copy())  # Копируем текущий кадр и добавляем его в список
    return frames  # Возвращаем список всех кадров


def save_frames(frames, name):
    # Сохраняем каждый кадр в указанной папке
    count_frames = 0
    for i, frame in enumerate(frames):
        count_frames = i
        frame.save(os.path.join('data', f'{name}_{i}.png'))
    return count_frames


def calculate_new_velocity_and_angle(V0, theta0, F, thetaF, t):
    """
    Calculate the new velocity components, angle, and distance traveled in X and Y directions.

    Parameters:
    V0 (float): Initial velocity magnitude.
    theta0 (float): Initial angle in radians.
    F (float): Magnitude of the applied force.
    thetaF (float): Angle of the applied force in radians.
    t (float): Time duration over which the force is applied (in milliseconds).

    Returns:
    tuple: New velocity components (Vx, Vy), their magnitude and angle,
           and distance traveled in X and Y directions (dx, dy).
    """

    # Calculate initial velocity components in Cartesian coordinates
    V0x = V0 * math.cos(theta0)
    V0y = V0 * math.sin(theta0)

    # Calculate force components in Cartesian coordinates (assuming mass = 1)
    Fx = F * math.cos(thetaF)
    Fy = F * math.sin(thetaF)

    # Update velocity components based on acceleration (force) over time
    # Note: t is in milliseconds; convert to seconds for calculations
    Vx = V0x + Fx * (t / 1000)
    Vy = V0y + Fy * (t / 1000)

    # Calculate new velocity magnitude and angle
    new_velocity = math.sqrt(Vx ** 2 + Vy ** 2)
    new_angle = math.atan2(Vy, Vx)  # Angle in radians

    return new_angle, new_velocity


def resultant_force(angle1, force1, angle2, force2):
    """
    Calculate the resultant force from two forces given their magnitudes and angles.

    Parameters:
    angle1 (float): Angle of the first force in radians.
    force1 (float): Magnitude of the first force.
    angle2 (float): Angle of the second force in radians.
    force2 (float): Magnitude of the second force.

    Returns:
    tuple: Resultant angle in radians and magnitude of the resultant force.
    """

    # Разложение сил на компоненты
    fx1 = force1 * math.cos(angle1)
    fy1 = force1 * math.sin(angle1)

    fx2 = force2 * math.cos(angle2)
    fy2 = force2 * math.sin(angle2)

    # Суммирование компонентов
    fx_resultant = fx1 + fx2
    fy_resultant = fy1 + fy2

    # Вычисление результирующей силы и угла
    resultant_magnitude = math.sqrt(fx_resultant ** 2 + fy_resultant ** 2)

    # Проверка на нулевую результирующую силу
    if resultant_magnitude == 0:
        resultant_angle = None  # или любое другое значение по умолчанию
    else:
        resultant_angle = math.atan2(fy_resultant, fx_resultant)

    return resultant_angle, resultant_magnitude


def are_points_collinear(x1, y1, x2, y2, x3, y3):
    """
    Check if three points A, B, and C are collinear.

    Parameters:
    (x1, y1): Coordinates of point A.
    (x2, y2): Coordinates of point B.
    (x3, y3): Coordinates of point C.

    Returns:
    bool: True if the points are collinear, False otherwise.
    """

    # Вычисление площади треугольника
    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))

    # Проверка на коллинеарность
    return area == 0


def find_circle_center(x1, y1, x2, y2, x3, y3):
    """
    Find the center of the circle that passes through three points A, B, and C.

    Parameters:
    (x1, y1): Coordinates of point A.
    (x2, y2): Coordinates of point B.
    (x3, y3): Coordinates of point C.

    Returns:
    (xc, yc): Coordinates of the center of the circle.
    """

    # Вычисление средних значений
    D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))

    if D == 0:
        raise ValueError("The points are collinear; no unique circle can be defined.")

    # Вычисление координат центра окружности
    xc = ((x1 ** 2 + y1 ** 2) * (y2 - y3) +
          (x2 ** 2 + y2 ** 2) * (y3 - y1) +
          (x3 ** 2 + y3 ** 2) * (y1 - y2)) / D

    yc = ((x1 ** 2 + y1 ** 2) * (x3 - x2) +
          (x2 ** 2 + y2 ** 2) * (x1 - x3) +
          (x3 ** 2 + y3 ** 2) * (x2 - x1)) / D

    return xc, yc


def find_ray_circle_intersection(ray_origin, target_point, radius):
    # Распаковка координат
    x0, y0 = ray_origin  # Центр окружности (начало луча)
    x1, y1 = target_point  # Произвольная точка

    # Вектор от центра окружности к произвольной точке
    dx = x1 - x0
    dy = y1 - y0

    # Нормализация вектора
    length = math.sqrt(dx ** 2 + dy ** 2)
    dx /= length
    dy /= length

    # Уравнение окружности: (x - x0)^2 + (y - y0)^2 = r^2
    # Подставляем уравнение линии: y = y0 + dy * t, x = x0 + dx * t
    # Получаем квадратное уравнение по t:

    a = dx ** 2 + dy ** 2
    b = 2 * (dx * (x0 - x0) + dy * (y0 - y0))  # Здесь cx и cy равны x0 и y0 соответственно
    c = (x0 - x0) ** 2 + (y0 - y0) ** 2 - radius ** 2  # cx и cy равны x0 и y0 соответственно

    discriminant = b ** 2 - 4 * a * c

    # Находим два значения t (временные параметры)
    t1 = (-b + math.sqrt(discriminant)) / (2 * a)
    t2 = (-b - math.sqrt(discriminant)) / (2 * a)

    # Выбираем ближайшую точку пересечения (t > 0)
    t = min(t for t in [t1, t2] if t > 0)

    # Находим координаты точки пересечения
    intersection_x = x0 + dx * t
    intersection_y = y0 + dy * t

    # Вычисляем угол наклона луча
    angle = math.atan2(dy, dx)

    return (intersection_x, intersection_y), angle


class BallHitbox(pygame.sprite.Sprite):
    def __init__(self, size, pos=(0, 0), color=(255, 0, 0)):
        super().__init__()
        self.image = pygame.Surface([size, size], pygame.SRCALPHA)
        pygame.draw.ellipse(self.image, color, [0, 0, size, size], 1)
        self.radius = size / 2  # Устанавливаем радиус для проверки коллизии
        self.x, self.y = pos

    def draw(self):
        screen.blit(self.image, (self.x, self.y))


class BackGround(pygame.sprite.Sprite):
    def __init__(self, image_file):
        super().__init__()
        self.name = image_file
        self.count_frames = save_frames(split_gif(self.name), self.name[0: -4])
        self.current_frame = 0
        self.fps = 20
        self.image = [pygame.transform.scale(load_image(f'{self.name[0: -4]}_{i}.png'), size) for i in
                      range(self.count_frames)]

    def draw(self):
        screen.blit(self.image[int(self.current_frame)], (0, 0))

    def animate(self, time):
        self.current_frame += time / (1000 / self.fps)
        self.current_frame %= self.count_frames


class Decor(pygame.sprite.Sprite):
    def __init__(self, pos, image_file):
        super().__init__()
        self.x, self.y = pos
        self.name = image_file

    def draw(self):
        screen.blit(self.name, (self.x, self.y))


class SegmentRoad:
    def __init__(self, hit_box, image_obj):
        self.image = image_obj
        self.hit_box = hit_box

    def draw(self):
        self.image.draw()
        self.hit_box.draw()


class Bal:
    def __init__(self, x, y, hitbox, decor, velocity=None):
        if velocity is None:
            velocity = [0, 0]
        self.x, self.y = x, y
        self.velocity = velocity
        self.hit_box = hitbox
        self.decor = decor
        self.V = [0.0, 0.0]
        self.F = [0.0, 0.0]
        self.Fg = [math.radians(270), 100]
        self.N = [0.0, 0.0]
        self.Fr = [0.0, 0.0]

    def draw(self):
        self.decor.draw()
        self.hit_box.draw()

    def animate(self, time):

        if r.list_segments:
            collide_segment = sorted(r.list_segments, key=lambda x: math.dist(
                (x.hit_box.x + x.hit_box.radius, x.hit_box.y + x.hit_box.radius),
                (self.x + self.hit_box.radius, self.y + self.hit_box.radius)))[0]
            if math.dist((collide_segment.hit_box.x + collide_segment.hit_box.radius,
                          collide_segment.hit_box.y + collide_segment.hit_box.radius), (self.x + self.hit_box.radius,
                                                                                        self.y + self.hit_box.radius)) <= self.hit_box.radius + collide_segment.hit_box.radius:
                collide_point, a = find_ray_circle_intersection((
                                                                collide_segment.hit_box.x + collide_segment.hit_box.radius,
                                                                collide_segment.hit_box.y + collide_segment.hit_box.radius),
                                                                (self.x + self.hit_box.radius,
                                                                 self.y + self.hit_box.radius),
                                                                collide_segment.hit_box.radius)
                dx = self.hit_box.radius * math.cos(a)
                dy = self.hit_box.radius * math.sin(a)
                new_point = (collide_point[0] + dx - self.hit_box.radius, collide_point[1] + dy - self.hit_box.radius)
                self.y = new_point[1]

                for i in r.list_segments:
                    i.hit_box.x -= new_point[0] - self.x
                    i.image.x -= new_point[0] - self.x
                R = self.V[1] ** 2
                i = r.list_segments.index(collide_segment)
                if i + 1 < len(r.list_segments) > 2:
                    x1, y1 = r.list_segments[i - 1].hit_box.x, r.list_segments[i - 1].hit_box.y
                    x2, y2 = r.list_segments[i].hit_box.x, r.list_segments[i].hit_box.y
                    x3, y3 = r.list_segments[i + 1].hit_box.x, r.list_segments[i + 1].hit_box.y
                    if not are_points_collinear(x1, y1, x2, y2, x3, y3):
                        R = find_circle_center(x1, y1, x2, y2, x3, y3)
                        R = math.dist((collide_segment.hit_box.x + collide_segment.hit_box.radius,
                                       collide_segment.hit_box.y + collide_segment.hit_box.radius), R) - r.width

                self.N[1] = self.F[1] * math.cos(a) + ((self.V[1] ** 2) / R)

            else:
                self.N[1] = 0.0
                self.V = list(calculate_new_velocity_and_angle(self.V[1], self.V[0], self.F[1], self.F[0], time))

        self.F = list(resultant_force(self.Fg[0], self.Fg[1], self.N[0], self.N[1]))
        print(self.V)
        vx = self.V[1] * math.cos(self.V[0])
        vy = self.V[1] * math.sin(self.V[0])
        dx = vx * time / 1000
        dy = vy * time / 1000
        self.y -= dy
        self.hit_box.y, self.decor.y = self.y, self.y
        if r.list_segments:
            for i in r.list_segments:
                i.hit_box.x -= dx
                i.image.x -= dx


class Road:
    def __init__(self, width_road=1, decor=None):
        self.list_segments = []
        self.decor = decor
        self.width = width_road
        self.vector_angle = 180
        self.end_line = True
        self.is_pressed = False

    def draw(self):
        for segment in self.list_segments:
            segment.draw()  # Отрисовываем каждый сегмент

    def animate(self, time):
        pos = (pygame.mouse.get_pos()[0] - self.width / 2, pygame.mouse.get_pos()[1] - self.width / 2)

        # Обработка нажатия мыши
        if pygame.mouse.get_pressed()[0]:

            if not self.list_segments: self.list_segments.append(
                SegmentRoad(BallHitbox(self.width, pos), Decor(pos, self.decor)))
            if not self.list_segments or math.dist((self.list_segments[-1].hit_box.x, self.list_segments[-1].hit_box.y),
                                                   pos) >= self.width / 2:
                last_segment_pos = (self.list_segments[-1].hit_box.x, self.list_segments[-1].hit_box.y)
                self.list_segments.append(
                    SegmentRoad(BallHitbox(self.width, pos), Decor(pos, self.decor)))
                if not self.end_line:
                    distance = math.dist(last_segment_pos, pos)
                    segment_count = int(distance // (self.width / 2))  # Определяем количество сегментов для добавления
                    for i in range(1, segment_count + 1):
                        new_pos = (
                            last_segment_pos[0] + (pos[0] - last_segment_pos[0]) * (i / (segment_count + 1)),
                            last_segment_pos[1] + (pos[1] - last_segment_pos[1]) * (i / (segment_count + 1))
                        )
                        self.list_segments.append(
                            SegmentRoad(BallHitbox(self.width, new_pos), Decor(new_pos, self.decor))
                        )
                self.is_pressed = True
                self.end_line = False
        elif self.is_pressed:
            self.end_line = True
            self.is_pressed = True

        # Обновляем позиции хитбоксов и текстур
        for segment in reversed(self.list_segments):
            if segment.hit_box.x < -self.width:
                self.list_segments.remove(segment)  # Удаляем сегмент из списка


class Button:
    def __init__(self, x: int, y: int, w: int, h: int, text: str, size_font: int, color_main: (int, int, int),
                 function, animation: bool):
        self.rect = pygame.Rect(x, y, w, h)
        self.text = text
        self.color_main = color_main
        self.action = function
        self.flag_click = False
        self.size_font = size_font
        self.font = pygame.font.SysFont('Arial', self.size_font)  # Шрифт для текста
        self.current_color = list(color_main)
        self.current_size = size_font
        self.time_animation = 500
        self.time_first_part = self.time_animation / 10
        self.time_second_part = self.time_animation - self.time_first_part
        self.real_time = 0
        self.animation = animation

    def draw(self):
        pygame.draw.rect(screen, self.color_main, self.rect, 10)
        text_surface = self.font.render(self.text, True, self.color_main)
        text_rect = text_surface.get_rect(center=self.rect.center)  # Центрируем текст
        screen.blit(text_surface, text_rect)

    def animate(self, time):
        if not self.flag_click:
            if event.type == pygame.MOUSEBUTTONDOWN:
                if self.rect.collidepoint(event.pos):  # Проверяем нажатие на кнопку
                    self.flag_click = True
                    self.action()
                    if self.animation:
                        if self.real_time == 0:
                            self.real_time += time
                        else:
                            self.real_time = time
        if self.flag_click:
            if event.type == pygame.MOUSEBUTTONUP:
                self.flag_click = False
        if self.real_time > 0:
            if self.real_time < self.time_first_part:
                self.current_size = self.size_font - (self.size_font * 0.5 * (self.real_time / self.time_first_part))
            elif (self.real_time - self.time_first_part) < self.time_second_part:
                self.current_size = self.size_font * 0.5 * (
                        ((self.real_time - self.time_first_part) / self.time_second_part) + 1)
            self.real_time += time
            if self.real_time > self.time_animation:
                self.real_time = 0
                self.current_size = self.size_font
            self.font = pygame.font.SysFont('Arial', int(self.current_size))


class Window:
    def __init__(self, list_objects: list, background: BackGround):
        self.list_objects = list_objects
        self.background = background
        self.clock = pygame.time.Clock()

    def update(self):
        time = self.clock.get_time()
        self.background.draw()
        self.background.animate(time)
        for i in range(len(self.list_objects)):
            self.list_objects[i].draw()
            self.list_objects[i].animate(time)
        self.clock.tick(fps)

    def add_obj(self, obj):
        self.list_objects.append(obj)

    def remove_obj(self, obj):
        self.list_objects.remove(obj)


if __name__ == "__main__":
    pygame.init()
    pygame.display.set_caption('Draw for Drive')
    size = width, height = pygame.display.Info().current_w, pygame.display.Info().current_h
    screen = pygame.display.set_mode(size, pygame.NOFRAME)
    running = True
    fps = 60


    def j():
        print('j')


    r = Road(10, pygame.transform.scale(load_image('yellowbal.png'), (10, 10)))
    bal = Bal(300, 200, BallHitbox(100, (300, 200)),
              Decor((300, 200), pygame.transform.scale(load_image('perpelbal.png'), (100, 100))))

    main_window = Window(
        [Button(100, 100, 200, 100, 'START', 50, (255, 0, 0), j, animation=True),
         r, bal],
        BackGround('mainmenu.gif'))
    active_window = 'main'
    dict_windows = {'main': main_window,
                    # 'select_your_car':
                    }
    while running:
        # внутри игрового цикла ещё один цикл
        # приёма и обработки сообщений
        for event in pygame.event.get():
            # при закрытии окна
            if event.type == pygame.QUIT:
                running = False
                # РЕАКЦИЯ НА ОСТАЛЬНЫЕ СОБЫТИЯ
            ...
        # отрисовка и изменение свойств объектов
        dict_windows[active_window].update()
        pygame.display.flip()

import pygame
import os
import sys
import math
from PIL import Image, ImageSequence
from pygame.examples.cursors import image


def load_image(name, colorkey=None):
    fullname = os.path.join('data', name)
    # если файл не существует, то выходим
    if not os.path.isfile(fullname):
        print(f"Файл с изображением '{fullname}' не найден")
        sys.exit()
    image = pygame.image.load(fullname)
    return image


def split_gif(gif_file):
    # Создаем полный путь к файлу
    gif_path = os.path.join('data', gif_file)  # 'data' - папка, gif_file - имя файла
    img = Image.open(gif_path)  # Открываем GIF-файл
    frames = []  # Инициализируем пустой список для хранения кадров
    for frame in ImageSequence.Iterator(img):  # Проходим по всем кадрам с помощью итератора
        frames.append(frame.copy())  # Копируем текущий кадр и добавляем его в список
    return frames  # Возвращаем список всех кадров


def save_frames(frames, name):
    # Сохраняем каждый кадр в указанной папке
    count_frames = 0
    for i, frame in enumerate(frames):
        count_frames = i
        frame.save(os.path.join('data', f'{name}_{i}.png'))
    return count_frames


class Ball(pygame.sprite.Sprite):
    def __init__(self, size, pos=(0, 0), color=(255, 0, 0)):
        super().__init__()
        self.image = pygame.Surface([size, size], pygame.SRCALPHA)
        pygame.draw.ellipse(self.image, color, [0, 0, size, size], 1)
        self.rect = self.image.get_rect()
        self.rect.center = pos
        self.radius = size // 2  # Устанавливаем радиус для проверки коллизии
        self.x, self.y = pos

    def draw(self):
        screen.blit(self.image, (self.x, self.y))


class BackGround(pygame.sprite.Sprite):
    def __init__(self, image_file):
        super().__init__()
        self.name = image_file
        self.count_frames = save_frames(split_gif(self.name), self.name[0: -4])
        self.current_frame = 0
        self.fps = 20

    def draw(self):
        screen.blit(pygame.transform.scale(load_image(f'{self.name[0: -4]}_{int(self.current_frame)}.png'), size),
                    (0, 0))

    def animate(self, time):
        self.current_frame += time / (1000 / self.fps)
        self.current_frame %= self.count_frames


class Decor(pygame.sprite.Sprite):
    def __init__(self, pos, gabarit, image_file=None):
        super().__init__()
        self.width = gabarit
        self.x, self.y = pos
        self.name = image_file

    def draw(self):
        if self.name: screen.blit(pygame.transform.scale(load_image(self.name), self.width), (self.x, self.y))


class Car:
    ...


class Object:
    def __init__(self, hit_box, image_obj):
        self.image = image_obj
        self.hit_box = hit_box

    def draw(self):
        self.image.draw()
        self.hit_box.draw()


class Road:
    def __init__(self, width_road=1, decor=None):
        self.list_segments = []
        self.decor = decor
        self.width = width_road
        self.speed = 100
        self.vector_angle = 180

    def draw(self):
        for i in range(len(self.list_segments)):
            self.list_segments[i].draw()

    def animate(self, time):
        if pygame.mouse.get_pressed()[0]:
            if not self.list_segments:
                self.list_segments.append(
                    Object(Ball(self.width, event.pos), Decor(event.pos, (self.width, self.width), self.decor)))
            if math.dist((self.list_segments[-1].hit_box.x, self.list_segments[-1].hit_box.y),
                         event.pos) >= self.width / 2:
                self.list_segments.append(
                    Object(Ball(self.width, event.pos), Decor(event.pos, (self.width, self.width), self.decor)))
        cnt = 0

        angle = math.radians(self.vector_angle)
        for i in range(len(self.list_segments)):

            if self.list_segments[i - cnt].hit_box.x < -self.width:
                self.list_segments.pop(i - cnt)
                cnt += 1
            if self.list_segments:
                self.list_segments[i - cnt].hit_box.x += time / 1000 * (self.speed * math.cos(angle))
                self.list_segments[i - cnt].hit_box.y += time / 1000 * (self.speed * math.sin(angle))
                self.list_segments[i - cnt].image.x += time / 1000 * (self.speed * math.cos(angle))
                self.list_segments[i - cnt].image.y += time / 1000 * (self.speed * math.sin(angle))


class Button:
    def __init__(self, x: int, y: int, w: int, h: int, text: str, size_font: int, color_main: (int, int, int),
                 function, animation: bool):
        self.rect = pygame.Rect(x, y, w, h)
        self.text = text
        self.color_main = color_main
        self.action = function
        self.flag_click = False
        self.size_font = size_font
        self.font = pygame.font.SysFont('Arial', self.size_font)  # Шрифт для текста
        self.current_color = list(color_main)
        self.current_size = size_font
        self.time_animation = 500
        self.time_first_part = self.time_animation / 10
        self.time_second_part = self.time_animation - self.time_first_part
        self.real_time = 0
        self.animation = animation

    def draw(self):
        pygame.draw.rect(screen, self.color_main, self.rect, 10)
        text_surface = self.font.render(self.text, True, self.color_main)
        text_rect = text_surface.get_rect(center=self.rect.center)  # Центрируем текст
        screen.blit(text_surface, text_rect)

    def animate(self, time):
        if not self.flag_click:
            if event.type == pygame.MOUSEBUTTONDOWN:
                if self.rect.collidepoint(event.pos):  # Проверяем нажатие на кнопку
                    self.flag_click = True
                    self.action()
                    if self.animation:
                        if self.real_time == 0:
                            self.real_time += time
                        else:
                            self.real_time = time

        if self.flag_click:
            if event.type == pygame.MOUSEBUTTONUP:
                self.flag_click = False

        if self.real_time > 0:
            if self.real_time < self.time_first_part:
                self.current_size = self.size_font - (self.size_font * 0.5 * (self.real_time / self.time_first_part))
            elif (self.real_time - self.time_first_part) < self.time_second_part:
                self.current_size = self.size_font * 0.5 * (
                        ((self.real_time - self.time_first_part) / self.time_second_part) + 1)
            self.real_time += time
            if self.real_time > self.time_animation:
                self.real_time = 0
                self.current_size = self.size_font

            self.font = pygame.font.SysFont('Arial', int(self.current_size))


class Window:
    def __init__(self, list_objects: list, background: BackGround):
        self.list_objects = list_objects
        self.background = background
        self.clock = pygame.time.Clock()

    def update(self):
        time = self.clock.get_time()
        self.background.draw()
        self.background.animate(time)
        for i in range(len(self.list_objects)):
            self.list_objects[i].draw()
            self.list_objects[i].animate(time)
        self.clock.tick(fps)

    def add_obj(self, obj):
        self.list_objects.append(obj)

    def remove_obj(self, obj):
        self.list_objects.remove(obj)


if __name__ == "__main__":
    pygame.init()
    pygame.display.set_caption('Draw for Drive')
    size = width, height = pygame.display.Info().current_w, pygame.display.Info().current_h
    screen = pygame.display.set_mode(size, pygame.NOFRAME)
    running = True
    fps = 120


    def j():
        print('j')


    main_window = Window([Button(100, 100, 200, 100, 'START', 50, (255, 0, 0), j, animation=True), Road(30)],
                         BackGround('mainmenu.gif'))

    active_window = 'main'
    dict_windows = {'main': main_window,
                    # 'select_your_car':
                    }

    while running:
        # внутри игрового цикла ещё один цикл
        # приёма и обработки сообщений
        for event in pygame.event.get():
            # при закрытии окна
            if event.type == pygame.QUIT:
                running = False
                # РЕАКЦИЯ НА ОСТАЛЬНЫЕ СОБЫТИЯ
            ...
        # отрисовка и изменение свойств объектов
        dict_windows[active_window].update()

        pygame.display.flip()
